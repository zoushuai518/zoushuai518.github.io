---
layout: post
title: "MySQL运行原理与基础架构"
category: mysql
comments: true
date:   2015-04-14 16:16:51
---

#### 1.MySQL基础

&nbsp;&nbsp;&nbsp;&nbsp;MySQL是一个开放源代码的关系数据库管理系统。原开发者为瑞典的MySQL AB公司，最早是在2001年MySQL3.23进入到管理员的视野并在之后获得广泛的应用。 2008年MySQL公司被Sun公司收购并发布了首个收购之后的版本MySQL5.1，该版本引入分区、基于行复制以及plugin API。移除了原有的BerkeyDB引擎，同时，Oracle收购InnoDB Oy发布了InnoDB plugin，这后来发展成为著名的InnoDB引擎。2010年Oracle收购Sun公司，这也使得MySQL归入Oracle门下，之后Oracle发布了收购以后的首个版本5.5，该版本主要改善集中在性能、扩展性、复制、分区以及对windows的支持。目前版本已发展到5.7。

&nbsp;&nbsp;&nbsp;&nbsp;和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。


#### 2.MySQL逻辑架构

![MySQL逻辑架构](/assets/postImage/mysql/mysql_luojijiagou.jpg "MySQL逻辑架构")

- 最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。

- 第二层架构主要完成大多少的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。

- 存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。

- 数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。


#### 3.并发控制和锁的概念

&nbsp;&nbsp;&nbsp;&nbsp;当数据库中有多个操作需要修改同一数据时，不可避免的会产生数据的脏读。这时就需要数据库具有良好的并发控制能力，这一切在MySQL中都是由服务器和存储引擎来实现的。

&nbsp;&nbsp;&nbsp;&nbsp;解决并发问题最有效的方案是引入了锁的机制，锁在功能上分为共享锁(shared lock)和排它锁(exclusive lock)即通常说的读锁和写锁。当一个select语句在执行时可以施加读锁，这样就可以允许其它的select操作进行，因为在这个过程中数据信息是不会被改变的这样就能够提高数据库的运行效率。当需要对数据更新时，就需要施加写锁了，不在允许其它的操作进行，以免产生数据的脏读和幻读。锁同样有粒度大小，有表级锁(table lock)和行级锁(row lock)，分别在数据操作的过程中完成行的锁定和表的锁定。这些根据不同的存储引擎所具有的特性也是不一样的。

&nbsp;&nbsp;&nbsp;&nbsp;MySQL大多数事务型的存储引擎都不是简单的行级锁，基于性能的考虑，他们一般都同时实现了多版本并发控制(MVCC)。这一方案也被Oracle等主流的关系数据库采用。它是通过保存数据中某个时间点的快照来实现的，这样就保证了每个事务看到的数据都是一致的。详细的实现原理可以参考《高性能MySQL》第三版。


#### 4.事务
- 简单的说事务就是一组原子性的SQL语句。可以将这组语句理解成一个工作单元，要么全部执行要么都不执行。在MySQL中可以使用如下命令操作事务：

<pre><code>
start transaction;
select ...
update ...
insert ...
commit;
</code></pre>

注意：默认MySQL中自动提交是开启的
![mysql_autocommit](/assets/postImage/mysql/mysql_autocommit.jpg "mysql_autocommit")

- 事务具有ACID的特性：  

&nbsp;&nbsp;&nbsp;&nbsp;原子性(atomicity):事务中的所有操作要么全部提交成功，要么全部失败回滚。  
&nbsp;&nbsp;&nbsp;&nbsp;一致性(consistency):数据库总是从一个一致性状态转换到另一个一致性状态。  
&nbsp;&nbsp;&nbsp;&nbsp;隔离性(isolation):一个事务所做的修改在提交之前对其它事务是不可见的。  
&nbsp;&nbsp;&nbsp;&nbsp;持久性(durability):一旦事务提交，其所做的修改便会永久保存在数据库中。  

- 事务的隔离级别：在SQL标准中定义了四种隔离级别：  

&nbsp;&nbsp;&nbsp;&nbsp;READ UNCOMMITTED(读未提交)：事务中的修改即使未提交也是对其它事务可见  
&nbsp;&nbsp;&nbsp;&nbsp;READ COMMITTED(读提交)：事务提交后所做的修改才会被另一个事务看见，可能产生一个事务中两次查询的结果不同。  
&nbsp;&nbsp;&nbsp;&nbsp;REPEATABLE READ(可重读)：只有当前事务提交才能看见另一个事务的修改结果。解决了一个事务中两次查询的结果不同的问题。  
&nbsp;&nbsp;&nbsp;&nbsp;SERIALIZABLE(串行化)：只有一个事务提交之后才会执行另一个事务。  

- MySQL中可以利用如下语句查询并临时修改隔离级别：

![mysql临时修改隔离级别](/assets/postImage/mysql/tx_isolation.jpg "mysql临时修改隔离级别")

- 死锁：  

两个或多个事务在同一资源上相互占用并请求锁定对方占用的资源，从而导致恶性循环的现象。MySQL的部分存储引擎能够检测到死锁的循环依赖并产生相应的错误。InnoDB引擎解决死锁的方案是将持有最少排它锁的事务进行回滚。


#### 5.MySQL存储引擎及应用方案

- MySQL采用插件式的存储引擎架构，可以根据不同的需求为不同的表设置不同的存储引擎。可以通过如下命令显示数据库中表的状态信息，以user表为例，显示如下：

![查看mysql表状态](/assets/postImage/mysql/engine.jpg "查看mysql表状态")

&nbsp;&nbsp;&nbsp;&nbsp;Name：显示的是表名  
&nbsp;&nbsp;&nbsp;&nbsp;Engine：显示存储引擎，该表存储引擎为MyISAM  
&nbsp;&nbsp;&nbsp;&nbsp;Row_format：显示行格式，对于MyISAM有Dynamic、Fixed和Compressed三种。非别表示表中有可变的数据类型，表中数据类型为固定的，以及表是压缩表的环境。  
&nbsp;&nbsp;&nbsp;&nbsp;Rows：显示表中行数  
&nbsp;&nbsp;&nbsp;&nbsp;Avg_row_length：平均行长度（字节）  
&nbsp;&nbsp;&nbsp;&nbsp;Data_length：数据长度（字节）  
&nbsp;&nbsp;&nbsp;&nbsp;Max_data_length：最大存储数据长度（字节）  
&nbsp;&nbsp;&nbsp;&nbsp;Data_free：已分配但未使用的空间，包括删除数据空余出来的空间  
&nbsp;&nbsp;&nbsp;&nbsp;Auto_increment：下一个插入行自动增长字段的值  
&nbsp;&nbsp;&nbsp;&nbsp;Create_time：表的创建时间  
&nbsp;&nbsp;&nbsp;&nbsp;Update_time：表数据的最后修改时间  
&nbsp;&nbsp;&nbsp;&nbsp;Collation：表的默认字符集及排序规则  
&nbsp;&nbsp;&nbsp;&nbsp;Checksum：如果启用，表示整个表的实时校验和  
&nbsp;&nbsp;&nbsp;&nbsp;Create_options：创建表示的一些其它选项  
&nbsp;&nbsp;&nbsp;&nbsp;Comment：额外的一些注释信息，根据存储引擎的不同表示的内容也不胫相同。  

- 存储引擎介绍：  

&nbsp;&nbsp;&nbsp;&nbsp;InnoDB引擎：  
&nbsp;&nbsp;&nbsp;&nbsp;1.将数据存储在表空间中，表空间由一系列的数据文件组成，由InnoDB管理；  
&nbsp;&nbsp;&nbsp;&nbsp;2.支持每个表的数据和索引存放在单独文件中(innodb_file_per_table)；  
&nbsp;&nbsp;&nbsp;&nbsp;3.支持事务，采用MVCC来控制并发，并实现标准的4个事务隔离级别，支持外键；  
&nbsp;&nbsp;&nbsp;&nbsp;4.索引基于聚簇索引建立，对于主键查询有较高性能；  
&nbsp;&nbsp;&nbsp;&nbsp;5.数据文件的平台无关性，支持数据在不同的架构平台移植；  
&nbsp;&nbsp;&nbsp;&nbsp;6.能够通过一些工具支持真正的热备。如XtraBackup等；  
&nbsp;&nbsp;&nbsp;&nbsp;7.内部进行自身优化如采取可预测性预读，能够自动在内存中创建hash索引等。  

&nbsp;&nbsp;&nbsp;&nbsp;MyISAM引擎：  
&nbsp;&nbsp;&nbsp;&nbsp;1.MySQL5.1中默认，不支持事务和行级锁；  
&nbsp;&nbsp;&nbsp;&nbsp;2.提供大量特性如全文索引、空间函数、压缩、延迟更新等；  
&nbsp;&nbsp;&nbsp;&nbsp;3.数据库故障后，安全恢复性差；  
&nbsp;&nbsp;&nbsp;&nbsp;4.对于只读数据可以忍受故障恢复，MyISAM依然非常适用；  
&nbsp;&nbsp;&nbsp;&nbsp;5.日志服务器的场景也比较适用，只需插入和数据读取操作；  
&nbsp;&nbsp;&nbsp;&nbsp;6.不支持单表一个文件，会将所有的数据和索引内容分别存在两个文件中；  
&nbsp;&nbsp;&nbsp;&nbsp;7.MyISAM对整张表加锁而不是对行，所以不适用写操作比较多的场景；  
&nbsp;&nbsp;&nbsp;&nbsp;8.支持索引缓存不支持数据缓存。  

&nbsp;&nbsp;&nbsp;&nbsp;Archive引擎：  
&nbsp;&nbsp;&nbsp;&nbsp;1.只支持insert和select操作；  
&nbsp;&nbsp;&nbsp;&nbsp;2.缓存所有的写数据并进行压缩存储，支持行级锁但不支持事务；  
&nbsp;&nbsp;&nbsp;&nbsp;3.适合高速插入和数据压缩，减少IO操作，适用于日志记录和归档服务器。  

&nbsp;&nbsp;&nbsp;&nbsp;Blackhole引擎：  
&nbsp;&nbsp;&nbsp;&nbsp;1.没有实现任何存储机制，会将插入的数据进行丢弃，但会存储二进制日志；  
&nbsp;&nbsp;&nbsp;&nbsp;2.会在一些特殊需要的复制架构的环境中使用。  

&nbsp;&nbsp;&nbsp;&nbsp;CSV引擎：  
&nbsp;&nbsp;&nbsp;&nbsp;1.可以打开CSV文件存储的数据，可以将存储的数据导出，并利用excel打开；  
&nbsp;&nbsp;&nbsp;&nbsp;2.可以作为一种数据交换的机制，同样经常使用。  

&nbsp;&nbsp;&nbsp;&nbsp;Memory引擎：  
&nbsp;&nbsp;&nbsp;&nbsp;1.将数据在内存中缓存，不消耗IO；  
&nbsp;&nbsp;&nbsp;&nbsp;2.存储数据速度较快但不会被保留，一般作为临时表的存储被使用。  

&nbsp;&nbsp;&nbsp;&nbsp;Federated引擎：  
&nbsp;&nbsp;&nbsp;&nbsp;能够访问远程服务器上的数据的存储引擎。能够建立一个连接连到远程服务器。  

&nbsp;&nbsp;&nbsp;&nbsp;Mrg_MyISAM引擎：  
&nbsp;&nbsp;&nbsp;&nbsp;将多个MYISAM表合并为一个。本身并不存储数据，数据存在MyISAM表中间。  

&nbsp;&nbsp;&nbsp;&nbsp;NDB集群引擎：  
&nbsp;&nbsp;&nbsp;&nbsp;MySQL Cluster专用。

- 第三方存储引擎：  

&nbsp;&nbsp;&nbsp;&nbsp;1.OLTP类：  
&nbsp;&nbsp;&nbsp;&nbsp;XtraDB：InnoDB的改进版本。  
&nbsp;&nbsp;&nbsp;&nbsp;PBXT：类似InnoDB，但提供引擎级别的复制和外键约束，适当支持SSD存储。  
&nbsp;&nbsp;&nbsp;&nbsp;TokuDB(开源)：支持分形树索引结构，支持海量数据的分析。  

&nbsp;&nbsp;&nbsp;&nbsp;2.列式存储引擎：MySQL默认是面向行的存储  
&nbsp;&nbsp;&nbsp;&nbsp;Infobright:  支持数十TB的数据量，为数据分析和数据仓库设计的。数据高度压缩。  
&nbsp;&nbsp;&nbsp;&nbsp;InfiniDB:可以在一组集群间做分布式查询，有商业版但没有典型应用案例。  

&nbsp;&nbsp;&nbsp;&nbsp;3.社区存储引擎：  
&nbsp;&nbsp;&nbsp;&nbsp;Aria：解决MyISAM崩溃安全恢复问题，并能够进行数据缓存。  
&nbsp;&nbsp;&nbsp;&nbsp;Groona: 全文索引引擎。  
&nbsp;&nbsp;&nbsp;&nbsp;QQGraph: 由Open query研发支持图操作，比如查找两点间最短距离。  
&nbsp;&nbsp;&nbsp;&nbsp;SphinxSE: 该引擎为Sphinx全文索引搜索服务器提供SQL接口。  
&nbsp;&nbsp;&nbsp;&nbsp;Spider: 支持sharding并能够基于分片实现并列查询。  
&nbsp;&nbsp;&nbsp;&nbsp;VPForMySQL: 支持垂直分区。  

- 存储引擎选取参考因素  

&nbsp;&nbsp;&nbsp;&nbsp;1.是否有事务需求  
&nbsp;&nbsp;&nbsp;&nbsp;如果需要事务支持最好选择InnoDB或者XtraDB，如果主要是select和insert操作MyISAM比较合适，一般使用日志型的应用。  

&nbsp;&nbsp;&nbsp;&nbsp;2.备份操作需求
&nbsp;&nbsp;&nbsp;&nbsp;如果能够关闭服务器进行备份，那么该因素可以忽略，如果需要在线进行热备份，则InnoDB引擎是一个不错的选择。  

&nbsp;&nbsp;&nbsp;&nbsp;3.故障恢复需求  
&nbsp;&nbsp;&nbsp;&nbsp;在对恢复要求比较好的场景中推荐使用InnoDB，因为MyISAM数据损坏概率比较大而且恢复速度比较慢。  

&nbsp;&nbsp;&nbsp;&nbsp;4.性能上的需求  
&nbsp;&nbsp;&nbsp;&nbsp;有些业务需求只有某些特定的存储引擎才能够满足，如地理空间索引也只有MyISAM引擎支持。所以在应用架构需求环境中也需要管理员折衷考虑，当然从各方面比较而言，InnoDB引擎还是默认应该被推荐使用的。  

- 表引擎转换方法  

&nbsp;&nbsp;&nbsp;&nbsp;1.直接修改  
![mysql修改表引擎](/assets/postImage/mysql/modify_engine.jpg "mysql修改表引擎")

&nbsp;&nbsp;&nbsp;&nbsp;2.备份修改
&nbsp;&nbsp;&nbsp;&nbsp;利用mysqldump备份工具将数据导出，修改create table语句中的存储引擎选项。注意修改的同时修改表名。

&nbsp;&nbsp;&nbsp;&nbsp;3.创建插入
![mysql修改表引擎](/assets/postImage/mysql/create_table_engine.jpg "mysql修改表引擎")


[network link](http://harisxiong.blog.51cto.com/7513022/1351370)

