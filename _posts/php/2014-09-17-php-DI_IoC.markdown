---
layout: post
title: "php 依赖注入(DI) & 控制反转(IoC)"
category: php
comments: true
date:   2014-09-17 10:59:51
---

<span class="impor">干货：依赖注入本质就是使代码耦合度更低；IoC容器是为了依赖过多程序过于复杂而诞生的，其目的就是配合依赖注入来解耦，使得代码更容易维护</span>


#一.依赖注入，控制反转(进阶)：

科普：  
首先依赖注入和控制反转说的是同一个东西，是一种设计模式，这种设计模式用来减少程序间的耦合  

先假设我们这里有一个类，类里面需要用到数据库连接，按照最最原始的办法，我们可能是这样写这个类的：  
{% highlight php linenos %}
<?php
class example {
    
    private $_db;

    function __construct(){
        include "./Lib/Db.php";
        $this->_db = new Db("localhost","root","123456","test");
    }

    function getList(){
        $this->_db->query("......");//这里具体sql语句就省略不写了
    }
}
?>
{% endhighlight %}

过程：  
在构造函数里先将数据库类文件include进来；  
然后又通过new Db并传入数据库连接信息实例化db类；  
之后getList方法就可以通过$this->_db来调用数据库类，实现数据库操作。  

看上去我们实现了想要的功能，但是这是一个噩梦的开始，以后example1,example2,example3....  越来越多的类需要用到db组件，如果都这么写的话，万一有一天数据库密码改了或者db类发生变化了，岂不是要回头修改所有类文件？  

ok，为了解决这个问题，工厂模式出现了，我们创建了一个Factory方法，并通过Factory::getDb()方法来获得db组件的实例：  

{% highlight php linenos %}
<?php
class Factory {
    public static function getDb(){
        include "./Lib/Db.php";
        return new Db("localhost","root","123456","test");
    }
}
?>
{% endhighlight %}

sample类变成：  
{% highlight php linenos %}
<?php
class example {
    
    private $_db;

    function __construct(){
        $this->_db = Factory::getDb();
    }

    function getList(){
        $this->_db->query("......");//这里具体sql语句就省略不写了
    }
}
?>
{% endhighlight %}

这样就完美了吗？再次想想一下以后example1,example2,example3....所有的类，你都需要在构造函数里通过Factory::getDb();获的一个Db实例，实际上你由原来的直接与Db类的耦合变为了和Factory工厂类的耦合，工厂类只是帮你把数据库连接信息给包装起来了，虽然当数据库信息发生变化时只要修改Factory::getDb()方法就可以了，但是突然有一天工厂方法需要改名，或者getDb方法需要改名，你又怎么办？  

当然这种需求其实还是很操蛋的，但有时候确实存在这种情况，一种解决方式是：  
我们不从example类内部实例化Db组件，我们依靠从外部的注入，什么意思呢？看下面的例子：  
{% highlight php linenos %}
<?php
class example {
    private $_db;
    function getList(){
        $this->_db->query("......");//这里具体sql语句就省略不写了
    }
    //从外部注入db连接
    function setDb($connection){
        $this->_db = $connection;
    }
}

//调用
$example = new example();
$example->setDb(Factory::getDb());//注入db连接
$example->getList();
?>
{% endhighlight %}
这样一来，example类完全与外部类解除耦合了，你可以看到Db类里面已经没有工厂方法或Db类的身影了。我们通过从外部调用example类的setDb方法，将连接实例直接注入进去。这样example完全不用关心db连接怎么生成的了。  

这就叫`依赖注入`，实现不是在代码内部创建依赖关系，而是让其作为一个参数传递，这使得我们的程序更容易维护，降低程序代码的耦合度，实现一种松耦合。  
这还没完，我们再假设example类里面除了db还要用到其他外部类，我们通过：  
{% highlight php linenos %}
<?php
$example->setDb(Factory::getDb());//注入db连接
$example->setFile(Factory::getFile());//注入文件处理类
$example->setImage(Factory::getImage());//注入Image处理类
// ...
?>
{% endhighlight %}

我们没完没了的写这么多set？累不累?  
ok，为了不用每次写这么多行代码，我们又去弄了一个工厂方法：  
{% highlight php linenos %}
<?php
class Factory {
    public static function getExample(){
        $example = new example();
        $example->setDb(Factory::getDb());//注入db连接
        $example->setFile(Factory::getFile());//注入文件处理类
        $example->setImage(Factory::getImage());//注入Image处理类
        return $expample;
    }

}
?>
{% endhighlight %}
实例化example时变为：  
{% highlight php linenos %}
<?php
$example=Factory::getExample();
$example->getList();
?>
{% endhighlight %}
似乎完美了，但是怎么感觉又回到了上面第一次用工厂方法时的场景？这确实不是一个好的解决方案，所以又提出了一个概念：`容器，又叫做IoC容器、DI容器。`  

我们本来是通过setXXX方法注入各种类，代码很长，方法很多，虽然可以通过一个工厂方法包装，但是还不是那么爽，好吧，我们不用setXXX方法了，这样也就不用工厂方法二次包装了，那么我们还怎么实现依赖注入呢？  
这里我们引入一个约定：在example类的构造函数里传入一个名为Di $di的参数，如下：  
{% highlight php linenos %}
<?php
class example {
    private $_di;
    function __construct(Di &$di){
        $this->_di = $di;
    }
    //通过di容器获取db实例
    function getList(){
        $this->_di->get('db')->query("......");//这里具体sql语句就省略不写了
    }
}

$di = new Di();
$di->set("db",function(){
   return new Db("localhost","root","root","test"); 
});
$example = new example($di);
$example->getList();
?>
{% endhighlight %}
Di就是IoC容器，所谓容器就是存放我们可能会用到的各种类的实例，我们通过$di->set()设置一个名为db的实例，因为是通过回调函数的方式传入的，所以set的时候并不会立即实例化db类，而是当$di->get('db')的时候才会实例化，同样，在设计di类的时候还可以融入单例模式。  
这样我们只要在全局范围内申明一个Di类，将所有需要注入的类放到容器里，然后将容器作为构造函数的参数传入到example，即可在example类里面从容器中获取实例。当然也不一定是构造函数，你也可以用一个 setDi(Di $di)的方法来传入Di容器，总之约定是你制定的，你自己清楚就行。  


#二.依赖注入，控制反转(正式demo)：

用PHP实现简单的控制反转(IOC) 依赖注入(DI)，用JSON配置文件  

1.编写 Hello 的 POJO，一个 Hello 接口，两个类实现这个接口的 sayHello() 方法。其中，中文版 CnHello 类，显示中文问候；英文 EnHello 类，显示英文问候。  
{% highlight php linenos %}
<?php
// Hello.php
/**
 * @author zoushuai
 */
interface Hello {
    public function sayHello();
}

//中文版
class EnHello implements Hello{
    private  $msg;

    function getMsg(){
        return $this->msg;
    }

    function setMsg($value){
        $this->msg=$value;
    }
    
    function sayHello(){
        echo "English Version:" . $this->msg;
    }
}

//英文版
class CnHello implements Hello{
    private  $msg;

    function getMsg(){
        return $this->msg;
    }

    function setMsg($value){
        $this->msg=$value;
    }

    function sayHello(){
        echo "中文版" . $this->msg;
    }
}
?>
{% endhighlight %}

2.自己设计了一个配置文件，使用 JSON 格式，里面有注释，看看就明白了  
{% highlight php linenos %}
<?php
//备注使用双反斜杆
[
    //英文版配置
    {
        //类ID，方便工厂查找
        "id": "enHello",

        //类名
        "class_name":"EnHello",

        //类文件
        "class_file":"Hello.php",

        //属性设置
        "properties":[
            {
                "name":"msg",
                "value":"Hello World!"
            }
        ]
    },

    //中文版配置
    {
        "id": "cnHello",
        "class_name":"CnHello",
        "class_file":"Hello.php",
        "properties":[
            {
                "name":"msg",
                "value":"世界你好！"
            }
        ]
    }
]
?>
{% endhighlight %}

3.测试。为类工厂指定上述配置文件。我们可以看见，对配置文件里的不同ID，返回了不同的类实例。调用每个实例的方法，分别输出了中文问候和英文问候。`可见，我们只需要改变配置文件的内容，就可以返回不同的类实例，而不需修改程序源代码。这就实现了简单的 IOC 或者 DI。`
{% highlight php linenos %}
<?php
// test.php
include_once("ClassFactory.php");
$factory = new ClassFactory("config.json");

$hello=$factory->getBean("enHello");
echo $hello->sayHello() .'<br>';

$hello=$factory->getBean("cnHello");
echo $hello->sayHello();

// 输出：
// English Version:Hello World!
// 中文版世界你好！
?>
{% endhighlight %}

4.`类工厂闪亮登场`。实现了一些简单功能，能够解析指定的配置文件，并根据配置文件生成类，同时设置指定的属性值，注释很详细，我就不多解释了。代码如下：
{% highlight php linenos %}
<?php
// ClassFactory.php
/**
 * @author zoushuai
 */

class ClassFactory {
    private $arr_conf;

    function ClassFactory($config_file){
        //读取配置文件内容
        $handle = fopen($config_file, r);
        $content = fread($handle, filesize($config_file));
        fclose($handle);

        //去除注释
        $content=preg_replace("<\/\/.*?\s>","",$content);

        //转成数组
        $this->arr_conf=json_decode($content,true);
    }

     function getBean($class_id){
        //查找匹配 $class_id 的类
        while(true){
            //挨个测试
            $conf=each($this->arr_conf);

            //找不到，返回 null
            if($conf==false) return null;

            if(strcmp($class_id,$conf["value"]["id"])===0){

                //如果匹配则装入类文件
                include_once($conf["value"]["class_file"]);

                //生成类的实例
                //print_r($conf["value"]["class_name"]);
                $obj=new $conf["value"]["class_name"]();

                //查找被设置的属性
                $arr_prop=$conf["value"]["properties"];
                while($prop=each($arr_prop)){
                    //生成属性的设置方法 setXXX ,第一个字母大写
                    $set_method="set". ucwords($prop["value"]["name"]);

                    //调用设置方法，并设置预设值
                    $obj->$set_method($prop["value"]["value"]);
                }

                //找到第一个，返回实例
                return $obj;
            }
        }
    }
}
?>
{% endhighlight %}

最后说一下，PHP是动态语言，利用一些语言特性，实现起来很简单，也没用到反射之类的概念。要是用 Java 实现可能要复杂点  



- [php依赖注入](http://www.yuansir-web.com/2014/03/20/%E7%90%86%E8%A7%A3php-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5laravel-ioc%E5%AE%B9%E5%99%A8/)
- [话说 依赖注入(DI) or 控制反转(IoC)](http://www.thinkphp.cn/topic/12180.html)
- [用PHP实现简单的控制反转(IOC) 依赖注入(DI)，用JSON配置文件](http://www.blogjava.net/myqiao/archive/2009/05/01/268454.html)
